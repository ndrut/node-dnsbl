{
  "name": "native-dns",
  "version": "0.4.1",
  "author": {
    "name": "Timothy J Fontaine",
    "email": "tjfontaine@gmail.com",
    "url": "http://atxconsulting.com"
  },
  "description": "Replacement for the core DNS module, includes server implementation",
  "keywords": [
    "dns",
    "bind",
    "native"
  ],
  "homepage": "http://github.com/tjfontaine/node-dns",
  "bugs": {
    "url": "http://github.com/tjfontaine/node-dns/issues"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/tjfontaine/node-dns.git"
  },
  "main": "dns.js",
  "engines": {
    "node": ">= 0.5.0"
  },
  "scripts": {
    "test": "nodeunit test"
  },
  "dependencies": {
    "buffercursor": ">= 0.0.5",
    "binaryheap": ">= 0.0.2",
    "ipaddr.js": ">= 0.1.1"
  },
  "devDependencies": {
    "optimist": "",
    "nodeunit": ">= 0.7.4"
  },
  "contributors": [
    {
      "name": "Timothy J Fontaine",
      "email": "tjfontaine@gmail.com"
    }
  ],
  "readme": "[![Build Status](https://secure.travis-ci.org/tjfontaine/node-dns.png)](http://travis-ci.org/tjfontaine/node-dns)\n\nnative-dns -- A replacement DNS stack for node.js\n=================================================\n\nInstallation\n------------\n\n`npm install native-dns` and then `var dns = require('native-dns');`\n\nClient\n------\n\nnative-dns exports what should be a 1:1 mapping of the upstream node.js dns\nmodule. That is to say if it's listed in the [docs](http://nodejs.org/docs/latest/api/dns.html)\nit should behave similarly. If it doesn't please file an [issue](https://github.com/tjfontaine/node-dns/issues/new)\n\nRequest\n-------\n\nBeyond matching the upstream module, native-dns also provides a method for\ncustomizing queries.\n\n```javascript\nvar dns = require('../dns'),\n  util = require('util');\n\nvar question = dns.Question({\n  name: 'www.google.com',\n  type: 'A',\n});\n\nvar start = new Date().getTime();\n\nvar req = dns.Request({\n  question: question,\n  server: { address: '8.8.8.8', port: 53, type: 'udp' },\n  timeout: 1000,\n});\n\nreq.on('timeout', function () {\n  console.log('Timeout in making request');\n});\n\nreq.on('message', function (err, answer) {\n  answer.answer.forEach(function (a) {\n    console.log(a.address);\n  });\n});\n\nreq.on('end', function () {\n  var delta = (new Date().getTime()) - start;\n  console.log('Finished processing request: ' + delta.toString() + 'ms');\n});\n\nreq.send();\n```\n\nRequest creation takes an object with the following fields\n\n * `question` -- an instance of Question (required)\n * `server` -- defines the remote end point (required)\n  - as an object it should be\n    * `address` -- a string ip address (required)\n    * `port` -- a number for the remote port (optional, default 53)\n    * `type` -- a string indicating `udp` or `tcp` (optional, default `udp`)\nYou do not need to indicate ipv4 or ipv6, the backend will handle that\n  - a string ip address\n * `timeout` -- a number in milliseconds indicating how long to wait for the\nrequest to finish. (optional, default 4000)\n * `try_edns` -- a boolean indicating whether to use an `EDNSPacket` (optional)\n * `cache` -- can be false to disable caching, or implement the cache model, or\nan instance of Cache but with a different store (optional, default\nplatform.cache)\n\nThere are only two methods\n\n * `send` -- sends the actual request to the remote endpoint\n * `cancel` -- cancels the request and ignores any responses\n\nRequest emits the following events\n\n * `message` -- This is where you get a response, passes `(err, answer)` where\nanswer is an instance of `Packet`\n * `timeout` -- Fired when the timeout is reached\n * `cancelled` -- Fired if the request is cancelled\n * `end` -- Always fired after a request finished, regardless of disposition\n\nPlatform\n--------\n\nIf you want to customize all `resolve` or `lookup`s with the replacement client\nstack you can modify the platform settings accessible in the top level `platform`\nobject.\n\nMethods:\n\n * `reload` -- Re-read system configuration files to populate name servers and\nhosts\n\nProperties:\n\n * `ready` -- Boolean whether requests are safe to transit, true after hosts\nand name servers are filled\n * `watching` -- Boolean indicating if system configuration files are watched\nfor changes, default to false (currently can only be enabled on !win32)\n * `name_servers` -- An array of servers used for resolving queries against\n  - Each entry is an object of `{ address: <string ip>, port: 53 }`\n  - On win32 this is hard coded to be google dns until there's a sane way to get\nthe data\n * `search_path` -- An array of domains to try and append after a failed lookup\n * `attempts` -- The number of retries for a failed lookup/timeout (default: 5)\n * `timeout` -- The time each query is allowed to take before trying another\nserver. (in milliseconds, default: 5000 (5 seconds))\n * `edns` -- Whether to try and send edns queries first (default: false)\n * `cache` -- The system wide cache used by default for `lookup` and `resolve`,\nset this to false to disable caching\n\nEvents:\n\n * `ready` -- Emitted after hosts and name servers have been loaded\n * `unready` -- Emitted when hosts and name servers configuration is being\nreloaded.\n\nServer\n------\n\nThere is also a rudimentary server implementation\n\n```javascript\nvar dns = require('../dns'),\n  server = dns.createServer();\n\nserver.on('request', function (request, response) {\n  //console.log(request)\n  response.answer.push(dns.A({\n    name: request.question[0].name,\n    address: '127.0.0.1',\n    ttl: 600,\n  }));\n  response.answer.push(dns.A({\n    name: request.question[0].name,\n    address: '127.0.0.2',\n    ttl: 600,\n  }));\n  response.additional.push(dns.A({\n    name: 'hostA.example.org',\n    address: '127.0.0.3',\n    ttl: 600,\n  }));\n  response.send();\n});\n\nserver.on('error', function (err, buff, req, res) {\n  console.log(err.stack);\n});\n\nserver.serve(15353);\n```\n\nServer creation\n\n * `createServer` and `createUDPServer` -- both create a `UDP` based server,\nthey accept an optional object for configuration,\n  - `{ dgram_type: 'udp4' }` is the default option, the other is `udp6`\n * `createTCPServer` -- creates a TCP based server\n\nServer methods\n\n * `serve(port, [address])` -- specify which port and optional address to listen\non\n * `close()` -- stop the server/close sockets.\n\nServer events\n\n * `listening` -- emitted when underlying socket is listening\n * `close` -- emitted when the underlying socket is closed\n * `request` -- emitted when a dns message is received, and the packet was\nsuccessfully unpacked, passes `(request, response)`\n  - Both `request` and `response` are instances of `Packet` when you're finished\ncreating the response, you merely need to call `.send()` and the packet will\nDoTheRightThing\n * `error` -- emitted when unable to properly unpack the packet, passed `(err, msg, response)`\n * `socketError` -- remap of the underlying socket for the server, passes `(err, socket)`\n\nPacket\n------\n\nProperties:\n\n * `header`\n  - `id` -- request id\n  - `qdcount` -- the number of questions (inferred from array size)\n  - `ancount` -- the number of questions (inferred from array size)\n  - `nscount` -- the number of questions (inferred from array size)\n  - `arcount` -- the number of questions (inferred from array size)\n  - `qr` -- is a query response\n  - `opcode`\n  - `aa` -- Authoritative Answer\n  - `tc` -- Truncation bit\n  - `rd` -- Recursion Desired\n  - `ra` -- Recursion Available\n  - `res1` -- Reserved field\n  - `res2` -- Reserved field\n  - `res3` -- Reserved field\n  - `rcode` -- Response Code (see `consts.NAME_TO_RCODE`)\n * `question` -- array of `Question`s\n * `answer` -- array of `ResourceRecord`s\n * `authority` -- array of `ResourceRecord`s\n * `additional` -- array of `ResourceRecord`s\n\nMethods:\n\n * `send()` -- Handles sending the packet to the right end point\n\nQuestion\n--------\n\nA `Question` is instantiated by passing an object like:\n\n * `name` -- i.e. 'www.google.com' (required)\n * `type` -- Either the string representation of the record type, or the integer\nvalue, see `consts.NAME_TO_QTYPE` (default: 'A')\n * `class` -- The class of service, default to 1 meaning internet\n\nResourceRecord\n--------------\n\nResourceRecords are what populate `answer`, `authority`, and `additional`.\nThis is a generic type, and each derived type inherits the following properties:\n\n * `name` -- The name of the resource\n * `type` -- The numerical representation of the resource record type\n * `class` -- The numerical representation of the class of service (usually 1 for internet)\n * `ttl` -- The Time To Live for the record, in seconds\n\nAvailable Types:\n\n * `SOA`\n  - `primary` -- string\n  - `admin` -- string\n  - `serial` -- number\n  - `refresh` -- number\n  - `retry` -- number\n  - `expiration` -- number\n  - `minimum` -- number\n * `A` and `AAAA`\n  - `address` -- string\n * `MX`\n  - `priority` -- number\n  - `exchange` -- string\n * `TXT`\n  - `data` -- string\n * `SRV`\n  - `priority` -- number\n  - `weight` -- number\n  - `port` -- number\n  - `target` -- string\n * `NS`\n  - `data` -- string\n * `CNAME`\n  - `data` -- string\n * `PTR`\n  - `data` -- string\n * `NAPTR`\n  - `order` -- number\n  - `preference` -- number\n  - `flags` -- string\n  - `service` -- string\n  - `regexp` -- string\n  - `replacement` -- string\n\nCache\n-----\n\nIf you perform a query on an A or AAAA type and it doesn't exist, the cache\nwill attempt to lookup a CNAME and then resolve that.\n\nThe constructor takes an optional object with the following properties:\n\n * `store` -- implements the cache store model (optional, default MemoryStore)\n\nMethods:\n\n * `lookup(question, cb)` -- for a given question check the cache store for\nexistence\n * `store(packet)` -- iterates over the resource records in a packet and sends\nthem to the cache store\n * `purge()` -- clears the cache store of all entries\n\nMemoryStore / Cache store model\n-------------------------------\n\n`MemoryStore(opts)` -- An in memory store based on a js object\n\nMethods:\n\n * `get(domain, key, cb)`\n  - `domain` is the holder under which keys will be applied,\n`key` is the subdomain that is being queried for.\nIf you `get('example.com', 'www', cb)` you are really asking for `www.example.com`.\n  - `cb(err, results)` -- results is an object of types and array of answers\n   * `{ 1: [{address: '127.0.0.1', ttl: 300, type: 1, class: 1}] }`\n * `set(domain, key, data, cb)`\n  - `domain` is the parent under which this key is stored.\n`key` is the subdomain we are storing, `data` is an object of types with an array of answers.\n   * `set('example.com', 'www', {1: [{class:1, type:1, ttl:300, address:'127.0.0.1'}]}, cb)`\n  - `cb(err, data)` -- cb merely returns the data that was passed.\n * `delete(domain[, key[, type]], cb)` -- delete all from a domain, a domain and key,\nor a domain a key and a type.\n\nLookup\n------\n\nIs a mechanism that given a store performs the common resolution pattern.\n\nGiven `example.com` previous added to a store:\n\n  * `www.example.com CNAME foo.bar.example.com.`\n  * `*.example.com A 127.0.0.1`\n\nA `Lookup(store, 'example.com', {name:'www.example.com', type:1}, cb)`\nwill resolve `www` to the CNAME and then search for `foo.bar.example.com` which\nwill return no results, and then search for `*.bar.example.com` which will also\nreturn no results, and ultimately searches for `*.example.com` which will return\nthe desired record.\n\nCallback will be called with `(err, results)` where results is an array suitable\nfor use in `Packet.answer`\n",
  "readmeFilename": "README.md",
  "_id": "native-dns@0.4.1",
  "_from": "native-dns@"
}
